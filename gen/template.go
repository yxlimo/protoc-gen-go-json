package gen

import (
	"io"
	"text/template"

	"github.com/golang/glog"
	"google.golang.org/protobuf/compiler/protogen"
)

// Options are the options to set for rendering the template.
type Options struct {
	// marshal options
	Multiline       bool
	UseEnumNumbers  bool
	EmitUnpopulated bool
	UseProtoNames   bool
	// options both work in marshal and unmarshal options
	AllowPartial bool
	// unmarshal options
	DiscardUnknown bool

	// generate sql.Scanner and driver.Valuer method for message
	SqlSupport bool
}

// This function is called with a param which contains the entire definition of a method.
func ApplyTemplate(w io.Writer, f *protogen.File, opts Options) error {
	if err := headerTemplate.Execute(w, tplHeader{
		File: f,
	}); err != nil {
		return err
	}

	return applyMessages(w, f.Messages, opts)
}

func applyMessages(w io.Writer, msgs []*protogen.Message, opts Options) error {
	for _, m := range msgs {

		if m.Desc.IsMapEntry() {
			glog.V(2).Infof("Skipping %s, mapentry message", m.GoIdent.GoName)
			continue
		}

		glog.V(2).Infof("Processing %s", m.GoIdent.GoName)
		if err := messageTemplate.Execute(w, tplMessage{
			Message: m,
			Options: opts,
		}); err != nil {
			return err
		}

		var canGenSql = true
		for _, f := range m.Fields {
			if f.GoName == "Value" || f.GoName == "Scan" {
				canGenSql = false
				break
			}
		}
		if opts.SqlSupport && canGenSql {
			if err := sqlTemplate.Execute(w, tplMessage{
				Message: m,
				Options: opts,
			}); err != nil {
				return err
			}
		}

		if err := applyMessages(w, m.Messages, opts); err != nil {
			return err
		}
	}

	return nil
}

type tplHeader struct {
	*protogen.File
}

type tplMessage struct {
	*protogen.Message
	Options
}

var (
	headerTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-json. DO NOT EDIT.
// source: {{.Proto.Name}}

package {{.GoPackageName}}

import (
	"fmt"
	"database/sql/driver"

	"google.golang.org/protobuf/encoding/protojson"
)

var _ driver.Valuer

`))

	messageTemplate = template.Must(template.New("message").Parse(`
// MarshalJSON implements json.Marshaler
func (msg *{{.GoIdent.GoName}}) MarshalJSON() ([]byte,error) {
	value, err :=  protojson.MarshalOptions{
		Multiline: {{.Multiline}},
		UseEnumNumbers: {{.UseEnumNumbers}},
		EmitUnpopulated: {{.EmitUnpopulated}},
		UseProtoNames: {{.UseProtoNames}},
		AllowPartial: {{.AllowPartial}},
	}.Marshal(msg)
	if err != nil {
		return nil, fmt.Errorf("marshalJSON {{.GoIdent.GoName}}: %w", err)
	}
	return value, nil
}

// UnmarshalJSON implements json.Unmarshaler
func (msg *{{.GoIdent.GoName}}) UnmarshalJSON(b []byte) error {
	err := protojson.UnmarshalOptions{
		AllowPartial: {{.AllowPartial}},
		DiscardUnknown: {{.DiscardUnknown}},
	}.Unmarshal(b, msg)
	if err != nil {
		return fmt.Errorf("unmarshalJSON {{.GoIdent.GoName}}: %w", err)
	}
	return nil
}


`))

	sqlTemplate = template.Must(template.New("sql").Parse(`
// Scan implements sql.Scanner
func (msg *{{.GoIdent.GoName}}) Scan(src interface{}) error {
	if msg == nil {
		return fmt.Errorf("scan into nil {{.GoIdent.GoName}}")
	}
	var value []byte
	switch v := src.(type) {
	case []byte:
		value = v
	case string:
		value = []byte(v)
	default:
		return fmt.Errorf("can't convert %v to {{.GoIdent.GoName}}, unsupported type %T", src, src)
	}
	
	if err := msg.UnmarshalJSON(value); err != nil {
		return fmt.Errorf("can't unmarshal {{.GoIdent.GoName}}: %w", err)
	}
	return nil
}

// Value implements driver.Valuer
func (msg {{.GoIdent.GoName}}) Value() (driver.Value, error) {
	value, err := msg.MarshalJSON()
	if err != nil {
		return nil, fmt.Errorf("can't marshal {{.GoIdent.GoName}}: %w", err)
	}
	return value, nil
}

`))
)
